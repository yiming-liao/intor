## API Report File for "intor"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { FallbackLocalesMap } from 'intor-translator';
import { JSX } from 'react/jsx-runtime';
import { Locale } from 'intor-translator';
import { LocaleMessages } from 'intor-translator';
import { LocalizedKey } from 'intor-translator';
import type { LocalizedPreKey } from 'intor-translator';
import { LocalizedReplacement } from 'intor-translator';
import { LocalizedRich } from 'intor-translator';
import { LocalizedValue } from 'intor-translator';
import type { LogryLevel } from 'logry';
import type { LogryPreset } from 'logry';
import type * as React_2 from 'react';
import { Replacement } from 'intor-translator';
import { Rich } from 'intor-translator';
import { ScopedKey } from 'intor-translator';
import { ScopedReplacement } from 'intor-translator';
import { ScopedRich } from 'intor-translator';
import { ScopedValue } from 'intor-translator';
import type { TranslateHandlers } from 'intor-translator';
import type { TranslateHook } from 'intor-translator';

// @public
export type BaseTranslator<M extends LocaleMessages, ReplacementShape = Replacement, RichShape = Rich, PK extends string | undefined = undefined> = {
    messages: M;
    locale: Locale<M>;
    hasKey: <K extends string = PK extends string ? ScopedKey<M, PK> : LocalizedKey<M>>(key?: K | (string & {}), targetLocale?: Locale<M>) => boolean;
    t: <K extends string = PK extends string ? ScopedKey<M, PK> : LocalizedKey<M>, R extends Replacement = LocalizedReplacement<ReplacementShape, K>>(key?: K | (string & {}), replacements?: R | Replacement) => [
    PK extends string ? ScopedValue<M, PK, K> : LocalizedValue<M, K>
    ] extends [never] ? string : PK extends string ? ScopedValue<M, PK, K> : LocalizedValue<M, K>;
    tRich: <K extends string = PK extends string ? ScopedKey<M, PK> : LocalizedKey<M>, RI = PK extends string ? ScopedRich<RichShape, PK, K> : LocalizedRich<RichShape, K>, RE = PK extends string ? ScopedReplacement<ReplacementShape, PK, K> : LocalizedReplacement<ReplacementShape, K>>(key?: K | (string & {}), tagRenderers?: HtmlTagRenderers<RI> | HtmlTagRenderers, replacements?: RE | Replacement) => string;
};

// @public
export type ClientLoaderOptions = Omit<RemoteLoader, "mode">;

// @public
export type CookieRawOptions = {
    persist?: boolean;
    name?: string;
    domain?: string;
    path?: string;
    maxAge?: number;
    httpOnly?: boolean;
    secure?: boolean;
    sameSite?: "lax" | "strict" | "none";
};

// @public
export type CookieResolvedOptions = Required<Omit<CookieRawOptions, "domain">> & {
    domain: string | undefined;
};

// @public
export type FallbackConfig = {
    Locales: Locale;
    Messages: LocaleMessages;
    Replacements: Replacement;
    Rich: Rich;
};

// @public
export type GenConfig<CK extends GenConfigKeys> = HasGen extends true ? CK extends GeneratedConfigKeys ? SafeExtract<IntorGeneratedTypes[CK]> : FallbackConfig : FallbackConfig;

// @public
export type GenConfigKeys = HasGen extends true ? [GeneratedConfigKeys] extends [never] ? string : GeneratedConfigKeys : string;

// @public
export type GeneratedConfigKeys = HasGen extends true ? Exclude<keyof IntorGeneratedTypes, INTOR_GENERATED_KEY> : never;

// @public (undocumented)
export type GenLocale<CK extends GenConfigKeys> = GenConfig<CK>["Locales"];

// @public (undocumented)
export type GenMessages<CK extends GenConfigKeys> = GenConfig<CK>["Messages"];

// @public (undocumented)
export type GenReplacements<CK extends GenConfigKeys> = GenConfig<CK>["Replacements"];

// @public (undocumented)
export type GenRich<CK extends GenConfigKeys> = GenConfig<CK>["Rich"];

// @public
export type HasGen = INTOR_GENERATED_KEY extends keyof IntorGeneratedTypes ? true : false;

// @public
export type HtmlTagRenderers<RichShape = Rich> = TagRenderers<string, RichShape>;

// @public
export type INTOR_GENERATED_KEY = "__intor_generated__";

// @public
export type IntorConfig = IntorResolvedConfig;

// @public
export function IntorProvider(input: IntorProviderProps): JSX.Element;

// @public
export interface IntorProviderProps {
    // (undocumented)
    children: React_2.ReactNode;
    // (undocumented)
    value: IntorValue;
}

// @public
export type IntorRawConfig = {
    readonly id?: string;
    readonly messages?: LocaleMessages;
    readonly defaultLocale: Locale;
    readonly supportedLocales: readonly Locale[];
    readonly fallbackLocales?: FallbackLocalesMap;
    readonly translator?: TranslatorOptions;
    readonly routing?: RoutingRawOptions;
    readonly cookie?: CookieRawOptions;
    readonly loader?: LoaderOptions;
    readonly server?: {
        loader?: ServerLoaderOptions;
    };
    readonly client?: {
        loader?: ClientLoaderOptions;
    };
    readonly logger?: Omit<LoggerOptions, "id">;
};

// @public
export type IntorResolvedConfig = {
    readonly id: string;
    readonly messages?: LocaleMessages;
    readonly defaultLocale: Locale;
    readonly supportedLocales: readonly Locale[];
    readonly fallbackLocales: FallbackLocalesMap;
    readonly translator?: TranslatorOptions;
    readonly routing: RoutingResolvedOptions;
    readonly cookie: CookieResolvedOptions;
    readonly loader?: LoaderOptions;
    readonly server?: {
        loader?: ServerLoaderOptions;
    };
    readonly client?: {
        loader?: ClientLoaderOptions;
    };
    readonly logger: LoggerOptions;
};

// @public
export interface IntorValue {
    // (undocumented)
    config: IntorConfig;
    // (undocumented)
    handlers?: TranslateHandlers;
    // (undocumented)
    hooks?: TranslateHook[];
    // (undocumented)
    isLoading?: boolean;
    // (undocumented)
    locale: string;
    // (undocumented)
    messages?: Readonly<LocaleMessages>;
    // (undocumented)
    onLocaleChange?: (newLocale: string) => Promise<void> | void;
}

// @public
export type LoaderOptions = LocalLoader | RemoteLoader;

// @public
export type LocalePathPrefix = "none" | "all" | "except-default";

// @public
export interface LocalLoader {
    concurrency?: number;
    mode: "local";
    namespaces?: string[];
    rootDir?: string;
}

// @public
export type LoggerOptions = {
    id: string;
    level?: LogryLevel;
    preset?: LogryPreset;
};

// @public
export type MessagesLoader = (config: IntorConfig, locale: string) => Promise<LocaleMessages>;

// @public
export type MessagesReader = (filePath: string) => Promise<unknown>;

// @public
export type MessagesReaders = Record<string, MessagesReader>;

// @public
export type ReactTagRenderers<RichShape = Rich> = TagRenderers<React.ReactNode, RichShape>;

// @public
export type ReactTranslator<M extends LocaleMessages, ReplacementShape = Replacement, RichShape = Rich, PK extends string | undefined = undefined> = Omit<BaseTranslator<M, ReplacementShape, RichShape, PK>, "tRich"> & {
    isLoading: boolean;
    setLocale: (locale: Locale<M>) => void;
    tRich: <K extends string = PK extends string ? ScopedKey<M, PK> : LocalizedKey<M>, RI = PK extends string ? ScopedRich<RichShape, PK, K> : LocalizedRich<RichShape, K>, RE = PK extends string ? ScopedReplacement<ReplacementShape, PK, K> : LocalizedReplacement<ReplacementShape, K>>(key?: K | (string & {}), tagRenderers?: ReactTagRenderers<RI> | ReactTagRenderers, replacements?: RE | Replacement) => React_2.ReactNode[];
};

// @public
export interface RemoteHeaders {
    "x-api-key"?: string;
    [key: string]: string | undefined;
    authorization?: string;
}

// @public
export interface RemoteLoader {
    concurrency?: number;
    headers?: RemoteHeaders;
    mode: "remote";
    namespaces?: string[];
    url: string;
}

// @public
export interface RoutingFlatOptions {
    // (undocumented)
    basePath?: string;
    // (undocumented)
    firstVisit?: NonNullable<RoutingStructuredOptions["inbound"]>["firstVisit"];
    // (undocumented)
    forceFullReload?: boolean;
    // (undocumented)
    host?: NonNullable<RoutingStructuredOptions["outbound"]>["host"];
    // (undocumented)
    localeCarrier?: RoutingLocaleCarrier;
    // (undocumented)
    localePrefix?: LocalePathPrefix;
    // (undocumented)
    localeSources?: RoutingLocaleSignal[];
    // (undocumented)
    queryKey?: string;
}

// @public
export type RoutingLocaleCarrier = "path" | "host" | "query";

// @public
export type RoutingLocaleSignal = RoutingLocaleCarrier | "cookie" | "detected";

// @public
export type RoutingLocaleSource = RoutingLocaleSignal | "default";

// @public
export type RoutingRawOptions = RoutingStructuredOptions & RoutingFlatOptions;

// @public
export type RoutingResolvedOptions = {
    basePath: string;
    localePrefix: LocalePathPrefix;
    inbound: {
        localeSources: RoutingLocaleSignal[];
        queryKey: string;
        firstVisit: {
            localeSource: "default" | "browser";
            redirect: boolean;
            persist: boolean;
        };
    };
    outbound: {
        localeCarrier: RoutingLocaleCarrier;
        queryKey: string;
        host: {
            map: Record<string, string>;
            default?: string;
        };
        forceFullReload: boolean;
    };
};

// @public
export type RoutingStructuredOptions = {
    basePath?: string;
    localePrefix?: LocalePathPrefix;
    inbound?: {
        localeSources?: RoutingLocaleSignal[];
        queryKey?: string;
        firstVisit?: {
            localeSource?: "default" | "browser";
            redirect?: boolean;
            persist?: boolean;
        };
    };
    outbound?: {
        localeCarrier?: RoutingLocaleCarrier;
        queryKey?: string;
        host?: {
            map: Record<string, string>;
            default?: string;
        };
        forceFullReload?: boolean;
    };
};

// @public
export type RuntimeFetch = (input: string | URL | Request, init?: RequestInit) => Promise<Response>;

// @public
export type SafeExtract<T> = T extends {
    Locales: infer L extends string;
    Messages: Record<"{locale}", infer M extends LocaleMessages[string]>;
    Replacements: infer RE;
    Rich: infer RI;
} ? {
    Locales: L;
    Messages: Record<L, M>;
    Replacements: RE;
    Rich: RI;
} : FallbackConfig;

// @public
export type ServerLoaderOptions = LoaderOptions;

// @public
export type TagRenderer<Output = string> = ((children: Output[]) => Output) | Output;

// @public
export type TagRenderers<Output = string, RichShape = Rich> = {
    [K in keyof RichShape]: TagRenderer<Output>;
} & Record<string, TagRenderer<Output>>;

// @public
export type TranslatorOptions = {
    loadingMessage?: string;
    missingMessage?: string;
};

// @public
export function useIntor(config: IntorConfig, loader: MessagesLoader): Pick<IntorValue, "config" | "locale" | "messages" | "isLoading" | "onLocaleChange">;

// @public
export function useTranslator<CK extends GenConfigKeys = "__default__", ReplacementShape = GenReplacements<CK>, RichShape = GenRich<CK>, PK extends LocalizedPreKey<GenMessages<CK>> | undefined = undefined>(preKey?: PK): ReactTranslator<GenMessages<CK>, ReplacementShape, RichShape, PK>;

// (No @packageDocumentation comment for this package)

```
